# chapter 24: 클로저

- 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어에서 사용되는 중요한 특성
- 함수와 그 함수가 선언된 렉시컬 환경과의 조합

## 함수 객체의 내부 슬롯

- 자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 함수를 어디에 정의했는지에 따라 상위 스코프를 결정
- 함수는 자신의 내부 슬롯에 자신이 정의된 환경, 즉 상위 스코프의 참조를 저장

## 클로저와 렉시컬 환경

```tsx
const x = 1;
// ①
function outer() {
  const x = 10;
  const inner = function () {
    console.log(x);
  }; // ② return inner;
}
// outer 함수를 호출하면 중첩 함수 inner를 반환한다.
// 그리고 outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 팝되어 제거된다.
const innerFunc = outer(); // ③ innerFunc(); // ④ 10
```

- 외부 함수보다 중첩 함수가 더 오래 유지되는경우 중첩 함수는 이미 생명주기가 종료한 외부 함수의 변수를 참조할 수 있음 -> 이때 중첩 함수를 **클로저** 라고 부름
- 모든 함수가 기억하는 상위 스코프는 함수를 어디서 호출하든 상관없이 유지
- 함수를 어디서 호출하든 상관없이 함수는 언제나 자신이 기억하는 상위 스코프의 식별자를 참조, 식별자에 바인딩된 값을 변경할 수 있음
- 클로저에 의해 참조되는 상위 스코프의 변수 = **자유변수**

## 클로저의 활용

- 상태를 안전하게 변경하고 유지하기 위해 사용
- 상태를 안전하게 은닉 ( 의도치 않게 변경되지 않도록 ) & 특정 함수에게만 상태 변경을 허용하기 위해 사용

```tsx
// 카운트 상태 변수
let num = 0;
// 카운트 상태 변경 함수
const increase = function () {
  // 카운트 상태를 1만큼 증가시킨다.
  return ++num;
};
console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

- 위의 코드가 제대로 바르게 동작하기 위해서는 아래의 전제조건이 필요

1. 카운트 상태는 increase함수가 호출되기 전까지 변경되지 않고 유지되어야한다
2. 이를 위해 카운트 상태는 increase 함수만이 변경할 수 있어야한다.
   -> 하지만 카운트는 전역변수를 통해 관리 ==> 언재든지 누구나 접근할 수 있고 변경할 수 있음 (**암묵적 결합**)

[클로저를 사용했을때의 변화된 함수]

```tsx
// 카운트 상태 변경 함수
const increase = (function () {
  // 카운트 상태 변수
  let num = 0;

  // 클로저
  return function () {
    // 카운트 상태를 1만큼 증가시킨다.
    return ++num;
  };
})();
console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

- 즉시 실행함수가 호출되고 즉시 실행 함수가 반환한 함수가 increase 변수에 할당
- increase 변수에 할당된 함수는 자신이 정의된 위치에 의해 결정된 상위 스코프인 즉시 실행함수의 렉시컬 환경을 기억하는 클로저
  => 클로저는 상태가 의도치 않게 변경되지 않도록 안전하게 **은닉** 하면서 특정 함수에게만 상태변경을 허용하여 상태를 안전하게 변경하고 유지하기 위해 사용

## 캡슐화와 정보 은닉

- 캡슐화 : 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작
- 정보 은닉: 외부에 공개할 필요가 없는 구현의 일부를 외부에 공개되지 않도록 감추어 적절치 못한 접근으로부터 객체의 상태가 변경되는것을 방지해 정보를 보호하고 객체 간의 상호 의존성(결합도) 를 낮추는 효과를 가짐
