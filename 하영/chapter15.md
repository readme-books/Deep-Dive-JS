# chapter15 : let, const 키워드와 블록 레벨 스코프

## var 키워드로 선언한 변수의 문제점

- 변수 중복선언 허용

```tsx
var x = 1;
var y = 1;
// var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.
// 초기화문이 있는 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.
var x = 100;
// 초기화문이 없는 변수 선언문은 무시된다.
var y;
console.log(x); // 100
console.log(y); // 1
```

- var로 선언한 변수는 오로지 함수의 **코드블록만을 지역 스코프** 로 인정, **함수 외부**에서는 **모두 전역변수**

```tsx
var i = 10;
// for문에서 선언한 i는 전역 변수다. 이미 선언된 전역 변수 i가 있으므로 중복 선언된다.
for (var i = 0; i < 5; i++) {
  console.log(i); // 0 1 2 3 4
}
// 의도치 않게 i 변수의 값이 변경되었다.
console.log(i); // 5
```

- 할당문 이전에 변수를 참조하면 undefined를 반환
  : var 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어올려진것처럼 동작
  : 변수 호이스팅에 의해 var 변수는 변수 선언문 이전에 참조할 수 있다. (**에러는 발생하지않지만 할당문 이전에 변수 참조시 무조건 undefined를 반환**함)

  ## let 키워드

  - 변수 **중복 선언 금지**
    : 같은 변수 중복 선언시 문법 에러가 발생
  - **블록레벨 스코프**를 따른다.
    : 블록 내에서 선언된 변수는 지역변수, 따라서 전역에서는 코드 블럭 내에 지역변수를 참조할 수 없다.

  ```tsx
  let foo = 1; // 전역 변수
  { let foo = 2; // 지역 변수 let bar = 3; // 지역 변수 }
  console.log(foo); // 1
  console.log(bar); // ReferenceError: bar is not defined
  ```

- 변수 호이스팅이 발생하지 않는것처럼 동작
  : let변수를 변수 선언문 이전에 참조하면 참조 에러가 발생
  : 암묵적으로 **선언단계와 초기화 단계가 한번에 진행** -> 선언단계에서 스코프에 변수 식별자를 등록하고, 즉시 초기화 단계에서 undefined으로 변수를 초기화 함 -> 변수 선언문 이전에 변수에 접근해도 스코프에 변수가 존재하기 때문에 에러가 발생하지않는다.
  **TDZ**
  : 일시적 사각지대
  : 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간
  ![Image](https://github.com/user-attachments/assets/12717b28-db84-43d4-8406-9eccabcd08f3)

## const 키워드

- const 변수는 **선언과 동시에 초기화**가 된다.
- **블록 레벨 스코프**를 가지며 변수 호이스팅이 발생하지 않는것처럼 동작한다.

```tsx
{
  // 변수 호이스팅이 발생하지 않는 것처럼 동작한다 console.log(foo); // ReferenceError: Cannot access 'foo' before initialization const foo = 1;
  console.log(foo); // 1
}
// 블록 레벨 스코프를 갖는다.
console.log(foo); // ReferenceError: foo is not defined
```

- 재할당 금지된 변수
  : const 로 선언한 변수에 원시값을 할당할 경우 변수값을 변경 할 수 없음
  : 하지만 객체를 할당한 경우 값을 변경할 수 있다.
  => 새로운 값을 **재할당 하는것은 불가능**하지만 프로퍼티 동적 생성, 삭제, 프로퍼티 값의 변경을 통해 **객체를 변경하는 것은 가능** (이때 객체가 변경되더라도 변수에 할당된 참조값을 변경되지않음)
